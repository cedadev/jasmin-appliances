---
#####
## Playbook that provisions and then configures a Kubernetes
## cluster on OpenStack
#####

# Provision the cluster infrastructure
- hosts: openstack
  tasks:
    - import_tasks: tasks/install-dependencies.yml

    # Add the identity stack to the cluster and configure it as the gateway
    - include_role:
        name: jasmin.cluster-infra
      vars:
        cluster_name: "{{ identity_stack_name }}"
        cluster_stack_update: false
        cluster_gw_group: "{{ identity_gw_group_name }}"

    # Provision the Kubernetes infrastructure
    - import_tasks: tasks/infra/provision.yml
      vars:
        # These are the groups to use when no fixed IP is given
        cluster_groups: "{{ k8s_groups_no_ip }}"
        # These are the groups to use when a fixed IP is given
        cluster_groups_fixed_ip: "{{ k8s_groups_fixed_ip }}"
        # Tag to assign to the cluster
        cluster_tag: "{{ cluster_type.kubernetes }}"

# Gather facts for all hosts
- hosts: cluster
  tasks: []

- hosts: rke_hosts
  become: true
  tasks:
    - include_tasks: tasks/kubernetes/upgrade_os_packages.yml
    # Before installing Kubernetes, enroll as a FreeIPA client
    - include_tasks: tasks/identity/freeipa/client.yml

# Set the permissions for the cluster in FreeIPA
# We don't create a user group
# The admins group is granted the cluster-admin role via OIDC below
- hosts: freeipa_servers
  become: true
  tasks:
    - include_tasks: tasks/identity/freeipa/cluster_permissions.yml
      vars:
        create_users_group: false

# Create/delete the OIDC client for the cluster
# We create a single client for all Kubernetes clusters in the tenancy
# to avoid needing to share a secret for every cluster with every user
# This means that we don't want to delete the client when the cluster is deleted
- hosts: keycloak_servers
  become: true
  tasks:
    - include_tasks: tasks/identity/keycloak/oidc_client.yml
      vars:
        keycloak_client_id: "{{ cluster_name }}"
        keycloak_client_name: "Kubernetes cluster - {{ cluster_name }}"
        # Include redirect URIs for use with kubectl and the dashboard authenticating proxy
        keycloak_client_redirect_uris: >-
          [
            'http://localhost:8000',
            'urn:ietf:wg:oauth:2.0:oob',
            {%- if 'rke_masters' in groups -%}
            'https://{{ hostvars[groups.rke_masters | first].kube_dashboard_domain }}/oauth/callback',
            {%- endif -%}
          ]

# Install Kubernetes
- hosts: rke_hosts
  become: true
  any_errors_fatal: true
  pre_tasks:
    # Before starting, make sure that we have an Openstack trust
    # This is created on the Openstack host but persisted on the cluster nodes
    # These tasks set the openstack_trust_id and openstack_project_id variables
    - include_tasks: tasks/util/os_trust.yml

    - name: Set RKE node roles (masters)
      set_fact:
        rke_node_roles: [etcd, controlplane]
      when: inventory_hostname in groups.rke_masters

    - name: Set RKE node roles (workers)
      set_fact:
        rke_node_roles: [worker]
      when: inventory_hostname in groups.rke_workers
  roles:
    # Install Kubernetes using RKE
    - role: jasmin.rke
      vars:
        # In order to consume a single floating IP, we want to schedule the ingress controllers
        # on the controlplane nodes
        # However RKE doesn't allow us to specify tolerations
        # So we don't deploy ingress with RKE at all and deploy with Helm later
        rke_ingress_config: { provider: none }
        # Use the centos user with the cluster SSH key
        rke_ssh_user: centos
        rke_ssh_private_key: "{{ lookup('file', ansible_ssh_private_key_file) }}"
        rke_cloud_provider: openstack
        # Configure the API server to authenticate using Keycloak
        rke_extra_config:
          services:
            kube-api:
              extra_args:
                oidc-issuer-url: "{{ hostvars[groups.keycloak_servers | first].keycloak_oidc_issuer_url }}"
                oidc-client-id: "{{ hostvars[groups.keycloak_servers | first].keycloak_client_id }}"
                oidc-username-claim: preferred_username
                oidc-username-prefix: "oidc:"
                oidc-groups-claim: groups
                oidc-groups-prefix: "oidc:"
        # Add a cluster-role-binding granting cluster-admin for the oidc:admins group
        rke_extra_addons: |
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: oidc-admins-cluster-admin
          subjects:
            - apiGroup: rbac.authorization.k8s.io
              kind: Group
              name: oidc:admins
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: cluster-admin

- hosts: rke_masters
  become: true
  tasks:
    # helm/kubectl commands need to run on the first host in the play
    - include_role:
        name: jasmin.helm

    # Install the Nginx ingress controller first
    - name: Install Nginx ingress controller
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: nginx-ingress
        helm_release_chart: stable/nginx-ingress
        helm_release_namespace: nginx-ingress
        helm_release_values_template: templates/helm/nginx-ingress.yml

    # Open ports 80 and 443 for the ingress controller
    - name: Open HTTP(S) ports for ingress controller
      firewalld:
        service: "{{ item }}"
        permanent: true
        immediate: true
        state: enabled
      loop: [http, https]

    - name: Install cert-manager manifests
      command: >
        kubectl apply
          -f https://raw.githubusercontent.com/jetstack/cert-manager/{{ cert_manager_version }}/deploy/manifests/00-crds.yaml
          -f https://raw.githubusercontent.com/jetstack/cert-manager/{{ cert_manager_version }}/deploy/manifests/01-namespace.yaml

    - name: Install Jetstack Helm repository
      command: helm repo add jetstack https://charts.jetstack.io

    - name: Install cert-manager
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: cert-manager
        helm_release_chart: jetstack/cert-manager
        helm_release_version: "{{ cert_manager_version }}"
        helm_release_namespace: cert-manager

    - name: Configure LetsEncrypt issuer
      shell: |
        kubectl apply -f - <<EOF
        apiVersion: certmanager.k8s.io/v1alpha1
        kind: ClusterIssuer
        metadata:
          name: letsencrypt
        spec:
          acme:
            server: https://acme-v02.api.letsencrypt.org/directory
            privateKeySecretRef:
              name: letsencrypt
            # Enable the HTTP-01 challenge provider
            http01: {}
        EOF

    # Create a persistent secret token for the kube-dashboard proxy token encryption
    - name: Create persistent encryption key
      include_tasks: tasks/util/persistent_random_fact.yml
      vars:
        fact_name: kube_dashboard_proxy_encryption_key
        # 32 chars is important - this is an AES-256 key
        random_string_length: 32

    - name: Install Kubernetes dashboard
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: kube-dashboard
        helm_release_chart: stable/kubernetes-dashboard
        helm_release_namespace: kube-system
        helm_release_extra_args:
          - --set fullnameOverride=kubernetes-dashboard

    - name: Set manifests directory fact
      set_fact:
        kube_manifests_dir: "{{ ansible_env.HOME | default('root') }}/manifests"

    - name: Ensure manifests directory exists
      file:
        path: "{{ kube_manifests_dir }}"
        state: directory

    - name: Install dashboard proxy manifest
      template:
        src: templates/kubernetes/kube-dashboard-proxy.yml
        dest: "{{ kube_manifests_dir }}"
        mode: u=rw,g=r,o=
      vars:
        keycloak_oidc_issuer_url: "{{ hostvars[groups.keycloak_servers | first].keycloak_oidc_issuer_url }}"
        kube_dashboard_proxy_client_id: "{{ hostvars[groups.keycloak_servers | first].keycloak_client_id }}"
        kube_dashboard_proxy_client_secret: "{{ hostvars[groups.keycloak_servers | first].keycloak_client_secret }}"
        kube_dashboard_proxy_encryption_key: "{{ ansible_local.kube_dashboard_proxy_encryption_key }}"

    - name: Install dashboard proxy
      command: kubectl -n kube-system apply -f {{ kube_manifests_dir }}/kube-dashboard-proxy.yml

    - name: Wait for dashboard proxy to start
      command: kubectl -n kube-system rollout status deployment kube-dashboard-proxy
