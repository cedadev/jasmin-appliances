---
#####
## Playbook that provisions and then configures a Kubernetes
## cluster on OpenStack
#####

# Provision the cluster infrastructure
- hosts: openstack
  tasks:
    - import_tasks: tasks/install-dependencies.yml

    # Add the identity stack to the cluster and configure it as the gateway
    - include_role:
        name: jasmin.cluster-infra
      vars:
        cluster_name: "{{ identity_stack_name }}"
        cluster_stack_update: false
        cluster_gw_group: "{{ identity_gw_group_name }}"

    # Provision the Kubernetes infrastructure
    - import_tasks: tasks/infra/provision.yml
      vars:
        # These are the groups to use when no fixed IP is given
        cluster_groups: "{{ k8s_groups_no_ip }}"
        # These are the groups to use when a fixed IP is given
        cluster_groups_fixed_ip: "{{ k8s_groups_fixed_ip }}"
        # Tag to assign to the cluster
        cluster_tag: "{{ cluster_type.kubernetes }}"

# Gather facts for all hosts
- hosts: cluster
  tasks: []

- hosts: rke_hosts
  become: true
  tasks:
    - include_tasks: tasks/kubernetes/upgrade_os_packages.yml
    # Before installing Kubernetes, enroll as a FreeIPA client
    - include_tasks: tasks/identity/freeipa/client.yml

# Set the permissions for the cluster in FreeIPA
- hosts: freeipa_servers
  become: true
  tasks:
    - include_tasks: tasks/identity/freeipa/cluster_permissions.yml
      vars:
        # Create a users group, but don't grant SSH access
        # We will hook this group up to the cluster-admin role
        create_users_group: true

# Create/delete the OIDC client for the cluster
# We create a single client for all Kubernetes clusters in the tenancy
# to avoid needing to share a secret for every cluster with every user
# This means that we don't want to delete the client when the cluster is deleted
- hosts: keycloak_servers
  become: true
  tasks:
    - name: Set Keycloak redirect URIs
      set_fact:
        # Include redirect URIs for use with kubectl and the dashboards when enabled
        keycloak_client_redirect_uris: >-
          [
            'http://localhost:8000',
            'urn:ietf:wg:oauth:2.0:oob',
            {%- if kubernetes_dashboard_enable | default(true) -%}
            'https://{{ hostvars[groups.rke_masters | first].kubernetes_dashboard_domain }}/oauth/callback',
            {%- endif -%}
          ]
      when: cluster_state | default('present') == 'present'

    - include_tasks: tasks/identity/keycloak/oidc_client.yml
      vars:
        keycloak_client_id: "{{ cluster_name }}"
        keycloak_client_name: "Kubernetes cluster - {{ cluster_name }}"
        keycloak_client_state: "{{ cluster_state | default('present') }}"

# Install Kubernetes
- hosts: rke_hosts
  become: true
  any_errors_fatal: true
  pre_tasks:
    # Before starting, make sure that we have an Openstack trust
    # This is created on the Openstack host but persisted on the cluster nodes
    # These tasks set the openstack_trust_id and openstack_project_id variables
    - include_tasks: tasks/util/os_trust.yml

    - name: Set RKE node roles (masters)
      set_fact:
        rke_node_roles: [etcd, controlplane]
      when: inventory_hostname in groups.rke_masters

    - name: Set RKE node roles (workers)
      set_fact:
        rke_node_roles: [worker]
      when: inventory_hostname in groups.rke_workers
  roles:
    # Install Kubernetes using RKE
    - role: jasmin.rke
      vars:
        # In order to consume a single floating IP, we want to schedule the ingress controllers
        # on the controlplane nodes
        # However RKE doesn't allow us to specify tolerations
        # So we don't deploy ingress with RKE at all and deploy with Helm later
        rke_ingress_config: { provider: none }
        # Use the centos user with the cluster SSH key
        rke_ssh_user: centos
        rke_ssh_private_key: "{{ lookup('file', ansible_ssh_private_key_file) }}"
        rke_cloud_provider: openstack
        # Configure the API server to authenticate using Keycloak
        rke_extra_config:
          services:
            kube-api:
              extra_args:
                oidc-issuer-url: "{{ hostvars[groups.keycloak_servers | first].keycloak_oidc_issuer_url }}"
                oidc-client-id: "{{ hostvars[groups.keycloak_servers | first].keycloak_client_id }}"
                oidc-username-claim: preferred_username
                oidc-username-prefix: "oidc:"
                oidc-groups-claim: groups
                oidc-groups-prefix: "oidc:"
        # Grant the cluster-admin role to the global admins and cluster admins groups
        rke_extra_addons: |
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: oidc-admins-cluster-admin
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: cluster-admin
          subjects:
            - apiGroup: rbac.authorization.k8s.io
              kind: Group
              name: oidc:admins
            - apiGroup: rbac.authorization.k8s.io
              kind: Group
              name: oidc:{{ hostvars[groups.freeipa_servers | first].user_group_name }}

- hosts: rke_masters
  become: true
  tasks:
    # helm/kubectl commands need to run on the first host in the play
    - include_role:
        name: jasmin.helm

    - name: Install Helm repositories
      command: helm repo add {{ item.name }} {{ item.url }}
      loop:
        - name: stable
          url: https://kubernetes-charts.storage.googleapis.com/
        - name: jetstack
          url: https://charts.jetstack.io
        - name: cedadev
          url: https://cedadev.github.io/helm-charts
      loop_control:
        label: "{{ item.name }}"

    # Install the Nginx ingress controller first
    - name: Install Nginx ingress controller
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: nginx-ingress
        helm_release_chart: stable/nginx-ingress
        helm_release_namespace: nginx-ingress
        helm_release_values_template: templates/helm/nginx-ingress.yml

    # Open ports 80 and 443 for the ingress controller
    - name: Open HTTP(S) ports for ingress controller
      firewalld:
        service: "{{ item }}"
        permanent: true
        immediate: true
        state: enabled
      loop: [http, https]

    - name: Install cert-manager manifests
      command: >
        kubectl apply
          -f https://raw.githubusercontent.com/jetstack/cert-manager/{{ cert_manager_version }}/deploy/manifests/00-crds.yaml
          -f https://raw.githubusercontent.com/jetstack/cert-manager/{{ cert_manager_version }}/deploy/manifests/01-namespace.yaml

    - name: Install cert-manager
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: cert-manager
        helm_release_chart: jetstack/cert-manager
        helm_release_version: "{{ cert_manager_version }}"
        helm_release_namespace: cert-manager

    - name: Configure LetsEncrypt issuer
      shell: |
        kubectl apply -f - <<EOF
        apiVersion: certmanager.k8s.io/v1alpha1
        kind: ClusterIssuer
        metadata:
          name: letsencrypt
        spec:
          acme:
            server: https://acme{% if letsencrypt_staging | default(false) | bool %}-staging{% endif %}-v02.api.letsencrypt.org/directory
            privateKeySecretRef:
              name: letsencrypt
            # Enable the HTTP-01 challenge provider
            http01: {}
        EOF

    - name: Install Kubernetes dashboard
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: kubernetes-dashboard
        helm_release_chart: stable/kubernetes-dashboard
        helm_release_namespace: kube-system
        helm_release_extra_args:
          - --set fullnameOverride=kubernetes-dashboard
        helm_release_state: "{% if kubernetes_dashboard_enable | default(true) | bool %}present{% else %}absent{% endif %}"

    - name: Create Kubernetes dashboard proxy encryption key
      include_tasks: tasks/util/persistent_random_fact.yml
      vars:
        fact_name: kubernetes_dashboard_proxy_encryption_key
        # 32 chars is important - this is an AES-256 key
        random_string_length: 32

    - name: Install dashboard authenticating proxy
      include_role:
        name: jasmin.helm
        tasks_from: chart.yml
      vars:
        helm_release_name: kubernetes-dashboard-proxy
        helm_release_chart: cedadev/keycloak-gatekeeper
        helm_release_namespace: kube-system
        helm_release_values_template: templates/helm/keycloak-gatekeeper.yml
        helm_release_state: "{% if kubernetes_dashboard_enable | default(true) | bool %}present{% else %}absent{% endif %}"
        gatekeeper_discovery_url: "{{ hostvars[groups.keycloak_servers | first].keycloak_oidc_issuer_url }}"
        gatekeeper_client_id: "{{ hostvars[groups.keycloak_servers | first].keycloak_client_id }}"
        gatekeeper_client_secret: "{{ hostvars[groups.keycloak_servers | first].keycloak_client_secret }}"
        gatekeeper_upstream: https://kubernetes-dashboard
        gatekeeper_encryption_key: "{{ ansible_local.kubernetes_dashboard_proxy_encryption_key }}"
        gatekeeper_domain: "{{ kubernetes_dashboard_domain }}"
